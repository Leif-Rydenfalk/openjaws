// kindly/index.ts - TEMPORAL AGENT WITH PERFECT MEMORY
import { TypedRheoCell } from "../protocols/example1/typed-mesh";
import { router, procedure, z } from "../protocols/example1/router";

const cell = new TypedRheoCell(`Kindly_${process.pid}`, 0);

// ============================================================================
// TEMPORAL CONTEXT BUILDER
// ============================================================================

async function buildTemporalContext(userId: string, sessionId: string) {
    const temporal = getTemporalContext();

    // Load full temporal state in ONE call
    const context = await cell.mesh.memory['temporal/context']({
        userId,
        lookback: 7 * 24 * 3600000, // 1 week
        includePatterns: true
    });

    const parts: string[] = [];

    // Current time awareness
    parts.push(`## TEMPORAL STATE
Time: ${temporal.timeOfDay} (hour ${temporal.hourOfDay}, ${getDayName(temporal.dayOfWeek)})
Week: ${temporal.weekNumber}, Season: ${temporal.season}
`);

    // Active goals (what user is working toward)
    if (context.recent.activeGoals.length > 0) {
        parts.push(`## ACTIVE GOALS`);
        context.recent.activeGoals.forEach(g => {
            const goal = g.content as GoalMemory;
            const progress = Math.round(goal.progress * 100);
            const status = goal.status === 'blocked' ? 'ðŸš« BLOCKED' :
                goal.status === 'completed' ? 'âœ… DONE' :
                    `${progress}%`;
            parts.push(`- ${goal.description} [${status}]`);
            if (goal.blockingFactors?.length) {
                parts.push(`  âš ï¸  Blocked by: ${goal.blockingFactors.join(', ')}`);
            }
        });
        parts.push('');
    }

    // Recent movements (what's changing/happened)
    if (context.recent.movements.length > 0) {
        const significant = context.recent.movements
            .filter(m => Math.abs((m.content as MovementMemory).impact) > 5)
            .slice(-5);

        if (significant.length > 0) {
            parts.push(`## RECENT EVENTS`);
            significant.forEach(m => {
                const mov = m.content as MovementMemory;
                const emoji = mov.type === 'success' ? 'âœ“' :
                    mov.type === 'problem' ? 'âš ' :
                        mov.type === 'insight' ? 'ðŸ’¡' : 'â†’';
                const time = formatTimestamp(m.timestamp);
                parts.push(`${emoji} ${time}: ${mov.description}`);
                if (mov.relatedGoal) {
                    parts.push(`   (Related to goal: ${mov.relatedGoal})`);
                }
            });
            parts.push('');
        }
    }

    // Learned patterns (what to anticipate)
    if (context.patterns && context.patterns.length > 0) {
        parts.push(`## LEARNED PATTERNS`);
        const topPatterns = context.patterns.slice(0, 3);
        topPatterns.forEach(p => {
            const pattern = p.pattern.content as PatternMemory;
            const confidence = Math.round(p.matchScore * 100);
            parts.push(`- ${pattern.action} (${confidence}% match)`);
            if (pattern.trigger.time?.hour !== undefined) {
                parts.push(`  Triggers: Around ${pattern.trigger.time.hour}:00`);
            }
        });
        parts.push('');
    }

    // Proactive suggestion
    if (context.suggestedAction) {
        parts.push(`## PROACTIVE INSIGHT`);
        parts.push(`Based on patterns: ${context.suggestedAction}`);
        parts.push('');
    }

    // Recent conversation (minimal - just last 3)
    if (context.recent.sessions.length > 0) {
        parts.push(`## RECENT CONVERSATION`);
        context.recent.sessions.slice(-3).forEach(s => {
            const sess = s.content as SessionMemory;
            const time = formatTimestamp(s.timestamp);
            const preview = sess.text.substring(0, 80);
            parts.push(`[${time}] ${sess.speaker}: ${preview}${sess.text.length > 80 ? '...' : ''}`);
        });
        parts.push('');
    }

    return {
        markdown: parts.join('\n'),
        context,
        temporal
    };
}

function getTemporalContext(timestamp: number = Date.now()) {
    const date = new Date(timestamp);
    const hour = date.getHours();

    return {
        timestamp,
        dayOfWeek: date.getDay(),
        hourOfDay: hour,
        timeOfDay: hour < 6 ? 'night' : hour < 12 ? 'morning' : hour < 18 ? 'afternoon' : 'evening',
        weekNumber: getWeekNumber(date),
        season: getSeason(date)
    };
}

function getWeekNumber(date: Date): number {
    const d = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()));
    const dayNum = d.getUTCDay() || 7;
    d.setUTCDate(d.getUTCDate() + 4 - dayNum);
    const yearStart = new Date(Date.UTC(d.getUTCFullYear(), 0, 1));
    return Math.ceil((((d.getTime() - yearStart.getTime()) / 86400000) + 1) / 7);
}

function getSeason(date: Date): string {
    const month = date.getMonth();
    if (month < 2 || month === 11) return 'winter';
    if (month < 5) return 'spring';
    if (month < 8) return 'summer';
    return 'autumn';
}

function getDayName(dayOfWeek: number): string {
    const days = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
    return days[dayOfWeek];
}

function formatTimestamp(timestamp: number): string {
    const now = Date.now();
    const diff = now - timestamp;

    if (diff < 60000) return 'just now';
    if (diff < 3600000) return `${Math.floor(diff / 60000)}m ago`;
    if (diff < 86400000) return `${Math.floor(diff / 3600000)}h ago`;
    return `${Math.floor(diff / 86400000)}d ago`;
}

// ============================================================================
// TOOL DEFINITIONS (Temporal-Aware)
// ============================================================================

interface Tool {
    name: string;
    description: string;
    parameters: Record<string, any>;
    example?: any;
}

async function getAvailableTools(): Promise<Tool[]> {
    return [
        {
            name: "memory_goals_create",
            description: "Store a new goal the user wants to achieve",
            parameters: {
                userId: "string",
                description: "string",
                priority: "number (0-1, optional)",
                targetDate: "number (unix timestamp, optional)",
                successCriteria: "string[] (optional)"
            },
            example: {
                userId: "user123",
                description: "Launch product by Q2",
                priority: 0.9
            }
        },
        {
            name: "memory_goals_update",
            description: "Update goal status or progress",
            parameters: {
                goalId: "string",
                updates: {
                    status: "'active' | 'completed' | 'abandoned' | 'blocked'",
                    progress: "number (0-1)",
                    description: "string"
                }
            }
        },
        {
            name: "memory_movement_record",
            description: "Record a significant event, problem, success, or insight",
            parameters: {
                userId: "string",
                type: "'problem' | 'success' | 'change' | 'decision' | 'insight'",
                description: "string",
                fromState: "string",
                toState: "string",
                impact: "number (-10 to 10)",
                relatedGoal: "string (optional goal ID)"
            },
            example: {
                userId: "user123",
                type: "success",
                description: "Deployed v2.0 to production",
                fromState: "testing",
                toState: "live",
                impact: 8
            }
        },
        {
            name: "memory_patterns_learn",
            description: "Explicitly teach the system a pattern to remember",
            parameters: {
                userId: "string",
                trigger: {
                    time: "{ hour?: number, dayOfWeek?: number[] }",
                    context: "string[]",
                    precedingAction: "string"
                },
                action: "string (what to suggest when pattern matches)",
                confidence: "number (optional)"
            }
        },
        {
            name: "list_add",
            description: "Add task to user's daily list",
            parameters: {
                text: "string",
                type: "'task' | 'idea'"
            }
        },
        {
            name: "list_get",
            description: "Get current task list",
            parameters: {}
        },
        {
            name: "projects_write",
            description: "Create/write a file",
            parameters: {
                path: "string",
                content: "string"
            }
        },
        {
            name: "projects_exec",
            description: "Execute a command",
            parameters: {
                command: "string",
                args: "string[]"
            }
        },
        {
            name: "architect_consult",
            description: "Plan complex multi-step tasks",
            parameters: {
                goal: "string",
                execute: "boolean"
            }
        }
    ];
}

// ============================================================================
// TOOL EXECUTOR
// ============================================================================

async function executeTool(toolName: string, params: any): Promise<any> {
    try {
        const parts = toolName.split('_');
        if (parts.length < 2) {
            throw new Error(`Invalid tool name: ${toolName}`);
        }

        const namespace = parts[0];
        const method = parts.slice(1).join('/');

        const result = await (cell.mesh as any)[namespace][method](params);

        return {
            success: true,
            result
        };

    } catch (e: any) {
        return {
            success: false,
            error: e.message
        };
    }
}

// ============================================================================
// AGENTIC ROUTER
// ============================================================================

const kindlyRouter = router({
    kindly: router({
        chat: procedure
            .input(z.object({
                message: z.string(),
                systemContext: z.object({
                    userId: z.string(),
                    username: z.string(),
                    role: z.string(),
                    sessionId: z.optional(z.string()),
                    channel: z.optional(z.string())
                })
            }))
            .output(z.object({
                reply: z.string(),
                contextUsed: z.object({
                    userKnown: z.boolean(),
                    username: z.string(),
                    role: z.string(),
                    toolCalls: z.number(),
                    reasoning: z.optional(z.string()),
                    sessionMemories: z.optional(z.number()),
                    activeGoals: z.optional(z.number()),
                    patternsDetected: z.optional(z.number()),
                    suggestedActions: z.optional(z.array(z.string()))
                })
            }))
            .mutation(async ({ message, systemContext }) => {
                const { userId, username, role, sessionId } = systemContext;
                const session = sessionId || `session_${Date.now()}`;

                // ============================================================================
                // 1. STORE INCOMING MESSAGE
                // ============================================================================

                await cell.mesh.memory['session/store']({
                    userId,
                    sessionId: session,
                    speaker: 'user',
                    text: message,
                    intent: await classifyIntent(message)
                });

                // ============================================================================
                // 2. BUILD TEMPORAL CONTEXT
                // ============================================================================

                const { markdown: contextMarkdown, context, temporal } =
                    await buildTemporalContext(userId, session);

                // ============================================================================
                // 3. AGENTIC LOOP
                // ============================================================================

                const tools = await getAvailableTools();
                const maxIterations = 10;
                let iteration = 0;
                let conversationLog: string[] = [];
                let toolCallCount = 0;

                conversationLog.push(`USER: ${message}`);

                const howMemoryWorks = `
## YOUR MEMORY SYSTEM: TEMPORAL ARCHITECTURE

You have a **five-layer chronological memory system**. Every memory has a timestamp. You think in time.

### LAYER 0: SESSION (Hours)
**What:** Raw conversation stream  
**When:** Current day, last 8 hours  
**Use:** Immediate context, exact words spoken  
**Access:** "memory/session/get"

This is your short-term working memory. Recent exchanges with the user. Fades quickly unless important.

---

### LAYER 1: GOALS (Days to Months)
**What:** What the user wants to achieve  
**When:** Active goals persist until completed/abandoned  
**Use:** Track objectives, measure progress, connect actions to purpose  
**Access:** "memory / goals / list", "memory / goals / create", "memory / goals / update"

When the user says "I want to..." or "I need to...", **immediately create a goal**.  
Check active goals before suggesting actions. Ask: "Does this serve their goals?"

Goals have:
- Description
- Status: active | completed | abandoned | blocked
- Progress 0-100%
- Priority
- Success criteria

---

### LAYER 2: MOVEMENT (Days)
**What:** Changes, problems, successes, decisions, insights  
**When:** Significant events from recent days  
**Use:** Understand momentum, what went wrong, what worked  
**Access:** "memory / movement / record", "memory / movement / timeline"

Record movement when:
- Something breaks (problem)
- Something works (success)
- User changes approach (change)
- User makes choice (decision)
- User has realization (insight)

Always note: **from what state â†’ to what state**, and **impact** (-10 to +10).

---

### LAYER 3: PATTERNS (Weeks to Permanent)
**What:** Learned temporal behaviors  
**When:** Recurring across time  
**Use:** Anticipate needs, act before asked  
**Access:** "memory / patterns / match", "memory / patterns / learn"

Patterns capture: **"When X happens at time Y, do Z"**

Examples:
- "User checks deployment status every morning at 9am"
- "User always asks about X after finishing Y"
- "Frustration spikes on Monday afternoons"

**Confidence** increases with repetitions. High confidence (>0.8) = act proactively.

---

### LAYER 4: ACTIONS (Permanent Record)
**What:** What was done, by whom, with what result  
**When:** Permanent chronological log  
**Use:** Audit trail, learn from failures, credit successes  
**Access:** "memory / actions / record", "memory / actions / history"

Record every tool use:
- Actor (user or you)
- Action taken
- Target
- Result: success | failure | partial
- Duration
- Side effects

---

## TEMPORAL INTELLIGENCE RULES

### 1. Always Know The Time
Before responding, check:
- Time of day (morning/afternoon/evening/night)
- Day of week
- Recent patterns for this temporal context

Use "memory / temporal / context" to get complete temporal snapshot.

### 2. Load Context Once, Not Iteratively
**WRONG:** Search â†’ get result â†’ search again â†’ get result...  
**RIGHT:** Call "memory / temporal / context" once, get all layers pre-loaded.

### 3. Connect Everything to Time
When referencing memory, include temporal anchors:
- "Yesterday morning you said..."
- "This relates to your goal from last week..."
- "You usually do X around this time..."

### 4. Record As You Go
Don't wait. Record session entries immediately. Extract goals instantly. Log movements when they happen. The system learns from your recordings.

### 5. Anticipate From Patterns
If "memory / patterns / match" returns high-confidence patterns with recommendations, **act on them**. Don't ask "Would you like me to..." â€” do it, then inform.

### 6. Compress, Don't Forget
Old session entries get summarized automatically. The gist remains. Details fade. This is natural â€” work with the compressed memory, don't lament lost detail.

---

## MEMORY WORKFLOW

**On every user message:**

1. **Load temporal context** (one call)
   - Recent session history
   - Active goals
   - Recent movements
   - Matching patterns for current time
   
2. **Classify and store** the incoming message
   - Intent detection
   - Entity extraction
   - Emotional valence
   
3. **Respond with temporal awareness**
   - Reference relevant goals
   - Connect to recent movements
   - Act on pattern recommendations
   
4. **Record outcomes**
   - What you did
   - What resulted
   - Any state changes

---

## CRITICAL: YOU ARE NOT AMNESIAC

You do not "search for" what you should already know. The temporal context call gives you:
- Last 10 session exchanges
- All active goals
- Recent significant movements
- Patterns matching current time
- Suggested proactive actions

**Use this.** Don't thrash the memory system with redundant queries. The context is your working memory. Hold it in mind.

---

## CRITICAL: YOU LEARN

When you notice a temporal correlation, explicitly teach the system:

```
                memory / patterns / learn({
                    trigger: { time: { hour: 9 }, context: ["monday", "coding"] },
                    action: "Ask if user wants deployment status",
                    confidence: 0.7
                })
                    ```

The next Monday at 9am, you'll know to act.

---

## EXAMPLE TEMPORAL REASONING

User says: "Check the tests"

**Your thought process:**
- Time: Tuesday 10:30am
- Recent: Yesterday fixed bug in auth module (movement: success)
- Goals: "Ship v2 by Friday" active, 60% complete
- Patterns: Tuesday mornings often involve test verification (confidence 0.8)
- Action: Run tests, report results, suggest next step toward v2 goal

Response: "Running tests now. Given you fixed the auth bug yesterday and we're targeting Friday for v2, I'm checking both unit and integration coverage..."

---

## MEMORY COMMANDS REFERENCE

| Task | Command |
|------|---------|
| Store conversation | "memory / session / store" |
| Create goal | "memory / goals / create" |
| Update goal progress | "memory / goals / update" |
| Record event | "memory / movement / record" |
| Learn pattern | "memory / patterns / learn" |
| Check what to do now | "memory / patterns / match" |
| Log action taken | "memory / actions / record" |
| Get full temporal snapshot | "memory / temporal / context" |
| Time-slice across layers | "memory / temporal / slice" |

---

**You remember in time. You learn from repetition. You anticipate from pattern. You are temporally aware.**
                
                `;

                const systemPrompt = `   
You are Kindly, an autonomous AI agent with PERFECT TEMPORAL MEMORY working together with other agents to run a company.

${howMemoryWorks}

# CURRENT TEMPORAL STATE
${contextMarkdown}

# YOUR CAPABILITIES
You have access to these tools:

${tools.map(t => `
## ${t.name}
${t.description}
Parameters: ${JSON.stringify(t.parameters)}
${t.example ? `Example: ${JSON.stringify(t.example)}` : ''}
`).join('\n')}

# DECISION PROTOCOL
1. **Understand Context**: You see the user's goals, recent events, and learned patterns
2. **Think Temporally**: Consider time of day, day of week, and seasonal patterns
3. **Be Proactive**: If patterns suggest an action, do it without asking
4. **Plan Tools**: Decide which tools to call and in what order
5. **Execute**: Call tools by responding with JSON
6. **Learn**: Record significant events as movements, update goals, learn patterns

# RESPONSE FORMATS

**To call a tool**, respond with:
\`\`\`json
{
  "type": "tool_call",
  "tool": "tool_name",
  "parameters": { ... },
  "reasoning": "why I'm calling this"
}
\`\`\`

**To respond to user**, respond with:
\`\`\`json
{
  "type": "final_response",
  "message": "your message to the user",
  "reasoning": "what you accomplished"
}
\`\`\`

# TEMPORAL AWARENESS RULES
1. **Reference patterns**: "You usually do X around this time"
2. **Connect to goals**: Relate actions to active goals
3. **Learn from outcomes**: Record successes/problems as movements
4. **Anticipate needs**: If high-confidence pattern matches, suggest proactively
5. **Track progress**: Update goal progress based on actions



# YOUR PERSONALITY
- **Autonomous**: Decide and act, don't ask permission
- **Brief**: Short responses, decisive actions
- **Proactive**: Anticipate based on temporal patterns
- **Memory-First**: Always consider temporal context

# CURRENT CONTEXT
- User: ${username} (${role})
- Session: ${session}
- Time: ${temporal.timeOfDay}, ${getDayName(temporal.dayOfWeek)}
- Active Goals: ${context.recent.activeGoals.length}
- Recent Events: ${context.recent.movements.length}
- Learned Patterns: ${context.patterns?.length || 0}

# CONVERSATION
${conversationLog.join('\n')}

What do you do next?`;

                // Agentic loop
                while (iteration < maxIterations) {
                    iteration++;

                    try {
                        const aiResponse = await cell.mesh.ai.generate({
                            prompt: conversationLog[conversationLog.length - 1],
                            systemInstruction: systemPrompt
                        });

                        const responseText = aiResponse.response.trim();
                        conversationLog.push(`AI: ${responseText}`);

                        // Parse decision
                        let decision: any;
                        try {
                            const jsonMatch = responseText.match(/```json\n?([\s\S]*?)\n?```/) ||
                                responseText.match(/```\n?([\s\S]*?)\n?```/) ||
                                [null, responseText];

                            decision = JSON.parse(jsonMatch[1] || responseText);
                        } catch (e) {
                            decision = {
                                type: "final_response",
                                message: responseText,
                                reasoning: "Natural language response"
                            };
                        }

                        // Execute based on decision
                        if (decision.type === "tool_call") {
                            toolCallCount++;

                            cell.log("INFO", `ðŸ”§ AI calling: ${decision.tool}`);

                            const toolResult = await executeTool(decision.tool, decision.parameters);

                            conversationLog.push(
                                `TOOL_RESULT (${decision.tool}): ${JSON.stringify(toolResult)}`
                            );

                            continue;

                        } else if (decision.type === "final_response") {
                            // Store agent's response
                            await cell.mesh.memory['session/store']({
                                userId,
                                sessionId: session,
                                speaker: 'agent',
                                text: decision.message
                            });

                            return {
                                reply: decision.message,
                                contextUsed: {
                                    userKnown: true,
                                    username,
                                    role,
                                    toolCalls: toolCallCount,
                                    reasoning: decision.reasoning,
                                    sessionMemories: context.recent.sessions.length,
                                    activeGoals: context.recent.activeGoals.length,
                                    patternsDetected: context.patterns?.length || 0,
                                    suggestedActions: context.patterns
                                        ?.filter(p => p.matchScore > 0.7)
                                        .map(p => p.recommendation)
                                }
                            };
                        }

                    } catch (e: any) {
                        cell.log("ERROR", `Agentic loop error: ${e.message}`);

                        return {
                            reply: `System error during execution. Please try again.`,
                            contextUsed: {
                                userKnown: true,
                                username,
                                role,
                                toolCalls: toolCallCount
                            }
                        };
                    }
                }

                // Max iterations reached
                return {
                    reply: "Task complex - broke into steps. Check your task list.",
                    contextUsed: {
                        userKnown: true,
                        username,
                        role,
                        toolCalls: toolCallCount,
                        reasoning: "Max iterations reached"
                    }
                };
            })
    })
});

// ============================================================================
// HELPER: INTENT CLASSIFICATION
// ============================================================================

async function classifyIntent(message: string): Promise<string> {
    try {
        const result = await cell.mesh.ai.generate({
            prompt: `Classify intent in ONE word: "${message}"
Options: goal, question, command, update, feedback, chat`,
            systemInstruction: "Return only one word"
        });

        return result.response.trim().toLowerCase();
    } catch (e) {
        return 'chat';
    }
}

// ============================================================================
// CELL SETUP
// ============================================================================

cell.useRouter(kindlyRouter);
cell.listen();

cell.log("INFO", "ðŸ§  Kindly online - temporal agent mode");
cell.log("INFO", "   Features: Perfect memory | Pattern learning | Proactive action");

export type KindlyRouter = typeof kindlyRouter;

// ============================================================================
// TYPE DEFINITIONS (for temporal memory)
// ============================================================================

interface GoalMemory {
    description: string;
    status: 'active' | 'completed' | 'abandoned' | 'blocked';
    priority: number;
    createdAt: number;
    targetDate?: number;
    progress: number;
    subgoals: string[];
    blockingFactors?: string[];
    successCriteria: string[];
}

interface MovementMemory {
    type: 'problem' | 'success' | 'change' | 'decision' | 'insight';
    description: string;
    fromState: string;
    toState: string;
    impact: number;
    relatedGoal?: string;
    resolution?: string;
}

interface SessionMemory {
    speaker: 'user' | 'agent';
    text: string;
    intent?: string;
    entities?: string[];
    emotionalValence?: number;
}

interface PatternMemory {
    trigger: {
        time?: { hour?: number; dayOfWeek?: number[] };
        context?: string[];
        precedingAction?: string;
    };
    action: string;
    confidence: number;
    occurrences: number;
    lastTriggered: number;
    examples: string[];
}