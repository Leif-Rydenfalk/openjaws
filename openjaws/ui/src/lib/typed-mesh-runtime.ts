// ui/src/lib/typed-mesh-runtime.ts
// Type-safe mesh client for frontend (SvelteKit)
// Uses auto-generated types from mesh-types.d.ts

import { browser } from '$app/environment';

/**
 * Import the generated mesh types
 * These are auto-generated by the codegen cell from live mesh topology
 */
import type {
    MeshCapabilities,
    ValidCapability,
    CapabilityInput,
    CapabilityOutput
} from '../../../protocols/typed-mesh';

// ============================================================================
// TYPED MESH CLIENT
// ============================================================================

/**
 * Result type for mesh calls
 */
export interface MeshResult<T> {
    ok: boolean;
    value?: T;
    error?: {
        code: string;
        msg: string;
        from?: string;
    };
}

/**
 * Parse capability path into namespace and procedure
 */
type ParseCapability<T extends string> =
    T extends `${infer Namespace}/${infer Procedure}`
    ? { namespace: Namespace; procedure: Procedure }
    : never;

/**
 * Get all capabilities for a specific namespace
 */
type CapabilitiesForNamespace<TNamespace extends string> = {
    [K in ValidCapability]: ParseCapability<K>["namespace"] extends TNamespace
    ? K
    : never
}[ValidCapability];

/**
 * Convert capabilities into callable methods
 */
type NamespaceProcedures<TNamespace extends string> = {
    [K in CapabilitiesForNamespace<TNamespace> as ParseCapability<K>["procedure"]]:
    CapabilityInput<K> extends void
    ? () => Promise<CapabilityOutput<K>>
    : (input: CapabilityInput<K>) => Promise<CapabilityOutput<K>>
};

/**
 * Extract all unique namespaces
 */
type ExtractNamespaces<T extends string> =
    T extends `${infer NS}/${string}` ? NS : never;

type AllNamespaces = ExtractNamespaces<ValidCapability>;

/**
 * The typed mesh proxy - identical interface to backend cells
 */
export type TypedMeshProxy = {
    [TNamespace in AllNamespaces]: NamespaceProcedures<TNamespace>
};

// ============================================================================
// MESH CLIENT IMPLEMENTATION
// ============================================================================

class MeshClient {
    private endpoint = '/_mesh/call';
    private statusEndpoint = '/_mesh/status';

    /**
     * Get mesh status (for debugging)
     */
    async getStatus() {
        if (!browser) return null;

        try {
            const response = await fetch(this.statusEndpoint);
            if (response.ok) {
                return await response.json();
            }
        } catch (e) {
            console.error('[MeshClient] Status check failed:', e);
        }
        return null;
    }

    /**
     * Call a mesh capability with type safety
     */
    async call<T extends ValidCapability>(
        capability: T,
        args?: CapabilityInput<T>
    ): Promise<MeshResult<CapabilityOutput<T>>> {
        if (!browser) {
            console.warn(
                `[MeshClient] Warning: Calling mesh for '${capability}' during SSR. ` +
                `Use locals.cell.askMesh() instead.`
            );
        }

        try {
            const response = await fetch(this.endpoint, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    capability,
                    args: args ?? {}
                })
            });

            if (!response.ok) {
                return {
                    ok: false,
                    error: {
                        code: 'HTTP_ERROR',
                        msg: `HTTP ${response.status}: ${response.statusText}`
                    }
                };
            }

            const result = await response.json();
            return result as MeshResult<CapabilityOutput<T>>;

        } catch (error) {
            const err = error as Error;
            return {
                ok: false,
                error: {
                    code: 'NETWORK_ERROR',
                    msg: err.message
                }
            };
        }
    }

    /**
     * Create the typed proxy for ergonomic API
     */
    createProxy(): TypedMeshProxy {
        return new Proxy({} as TypedMeshProxy, {
            get: (_target, namespace: string) => {
                return new Proxy({}, {
                    get: (_subTarget, procedure: string) => {
                        return async (input?: any) => {
                            const capability = `${namespace}/${procedure}` as ValidCapability;
                            const result = await this.call(capability, input);

                            if (!result.ok) {
                                throw new Error(
                                    `Mesh call failed: ${capability}\n` +
                                    `Error: ${result.error?.msg || 'Unknown error'}`
                                );
                            }

                            return result.value!;
                        };
                    }
                });
            }
        });
    }
}

// ============================================================================
// EXPORTED API
// ============================================================================

const client = new MeshClient();

/**
 * The main mesh client - provides same API as backend TypedRheoCell
 * 
 * Usage:
 *   const health = await mesh.mesh.health();
 *   const items = await mesh.list.get();
 *   const result = await mesh.ai.generate({ prompt: "..." });
 */
export const mesh = client.createProxy();

/**
 * Direct call method for when you need more control
 * 
 * Usage:
 *   const result = await meshCall("ai/generate", { prompt: "..." });
 *   if (result.ok) {
 *     console.log(result.value.response);
 *   }
 */
export async function meshCall<T extends ValidCapability>(
    capability: T,
    args?: CapabilityInput<T>
): Promise<MeshResult<CapabilityOutput<T>>> {
    return client.call(capability, args);
}

/**
 * Get mesh status (for debugging)
 */
export async function getMeshStatus() {
    return client.getStatus();
}

/**
 * Check if a capability is available in the mesh
 */
export function hasCapability(capability: string): capability is ValidCapability {
    // This is just a type guard - actual availability checked at runtime
    return capability.includes('/');
}

/**
 * Get type information for a capability (compile-time only)
 */
export type CapabilityInfo<T extends ValidCapability> = {
    input: CapabilityInput<T>;
    output: CapabilityOutput<T>;
};