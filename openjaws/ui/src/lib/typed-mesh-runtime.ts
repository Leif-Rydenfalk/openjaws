// ui/src/lib/typed-mesh-runtime.ts
// Type-safe mesh client for frontend (SvelteKit)
// This provides the EXACT same API as backend cells, but routes through HTTP

import { browser } from '$app/environment';

/**
 * Import the generated mesh types
 * These are auto-generated by the codegen cell from live mesh topology
 */
import type { MeshCapabilities, ValidCapability } from '../../../mesh-types';

// ============================================================================
// TYPED MESH CLIENT
// ============================================================================

/**
 * Result type for mesh calls
 */
export interface MeshResult<T> {
    ok: boolean;
    value?: T;
    error?: {
        code: string;
        msg: string;
        from?: string;
    };
}

/**
 * Parse capability path into namespace and procedure
 */
type ParseCapability<T extends string> =
    T extends `${infer Namespace}/${infer Procedure}`
    ? { namespace: Namespace; procedure: Procedure }
    : never;

/**
 * Get all capabilities for a specific namespace
 */
type CapabilitiesForNamespace<TNamespace extends string> = {
    [K in ValidCapability]: ParseCapability<K>["namespace"] extends TNamespace
    ? K
    : never
}[ValidCapability];

/**
 * Convert capabilities into callable methods
 */
type NamespaceProcedures<TNamespace extends string> = {
    [K in CapabilitiesForNamespace<TNamespace> as ParseCapability<K>["procedure"]]:
    MeshCapabilities[K]["input"] extends void
    ? () => Promise<MeshCapabilities[K]["output"]>
    : (input: MeshCapabilities[K]["input"]) => Promise<MeshCapabilities[K]["output"]>
};

/**
 * Extract all unique namespaces
 */
type ExtractNamespaces<T extends string> =
    T extends `${infer NS}/${string}` ? NS : never;

type AllNamespaces = ExtractNamespaces<ValidCapability>;

/**
 * The typed mesh proxy - identical interface to backend cells
 */
export type TypedMeshProxy = {
    [TNamespace in AllNamespaces]: NamespaceProcedures<TNamespace>
};

// ============================================================================
// MESH CLIENT IMPLEMENTATION
// ============================================================================

class MeshClient {
    private endpoint = '/_mesh/call';

    /**
     * Call a mesh capability with type safety
     */
    async call<T extends ValidCapability>(
        capability: T,
        args?: MeshCapabilities[T]["input"]
    ): Promise<MeshResult<MeshCapabilities[T]["output"]>> {
        if (!browser) {
            console.warn(
                `[MeshClient] Warning: Calling mesh for '${capability}' during SSR. ` +
                `Use locals.cell.askMesh() instead.`
            );
        }

        try {
            const response = await fetch(this.endpoint, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    capability,
                    args: args ?? {}
                })
            });

            if (!response.ok) {
                return {
                    ok: false,
                    error: {
                        code: 'HTTP_ERROR',
                        msg: `HTTP ${response.status}: ${response.statusText}`
                    }
                };
            }

            const result = await response.json();
            return result as MeshResult<MeshCapabilities[T]["output"]>;

        } catch (error) {
            const err = error as Error;
            return {
                ok: false,
                error: {
                    code: 'NETWORK_ERROR',
                    msg: err.message
                }
            };
        }
    }

    /**
     * Create the typed proxy for ergonomic API
     */
    createProxy(): TypedMeshProxy {
        return new Proxy({} as TypedMeshProxy, {
            get: (_target, namespace: string) => {
                return new Proxy({}, {
                    get: (_subTarget, procedure: string) => {
                        return async (input?: any) => {
                            const capability = `${namespace}/${procedure}` as ValidCapability;
                            const result = await this.call(capability, input);

                            if (!result.ok) {
                                throw new Error(
                                    `Mesh call failed: ${capability}\n` +
                                    `Error: ${result.error?.msg || 'Unknown error'}`
                                );
                            }

                            return result.value!;
                        };
                    }
                });
            }
        });
    }
}

// ============================================================================
// EXPORTED API
// ============================================================================

/**
 * The main mesh client - provides same API as backend TypedRheoCell
 * 
 * Usage:
 *   const health = await mesh.mesh.health();
 *   const items = await mesh.list.get();
 *   const result = await mesh.ai.generate({ prompt: "..." });
 */
export const mesh = new MeshClient().createProxy();

/**
 * Direct call method for when you need more control
 * 
 * Usage:
 *   const result = await meshCall("ai/generate", { prompt: "..." });
 *   if (result.ok) {
 *     console.log(result.value.response);
 *   }
 */
export async function meshCall<T extends ValidCapability>(
    capability: T,
    args?: MeshCapabilities[T]["input"]
): Promise<MeshResult<MeshCapabilities[T]["output"]>> {
    return new MeshClient().call(capability, args);
}

/**
 * Check if a capability is available in the mesh
 */
export function hasCapability(capability: string): capability is ValidCapability {
    // This is just a type guard - actual availability checked at runtime
    return capability.includes('/');
}

/**
 * Get type information for a capability (compile-time only)
 */
export type CapabilityInfo<T extends ValidCapability> = {
    input: MeshCapabilities[T]["input"];
    output: MeshCapabilities[T]["output"];
};

// ============================================================================
// USAGE EXAMPLES
// ============================================================================

/*

Example 1: Basic mesh calls
────────────────────────────

import { mesh } from '$lib/typed-mesh-runtime';

// ✅ Fully typed - autocomplete and type checking
const health = await mesh.mesh.health();
console.log(`${health.totalCells} cells online`);

const items = await mesh.list.get();
items.items.forEach(item => console.log(item.text));


Example 2: With error handling
────────────────────────────────

import { meshCall } from '$lib/typed-mesh-runtime';

const result = await meshCall("ai/generate", { 
    prompt: "What is TypeScript?" 
});

if (result.ok) {
    console.log(result.value.response);
} else {
    console.error(result.error.msg);
}


Example 3: Reactive Svelte store
──────────────────────────────────

import { writable } from 'svelte/store';
import { mesh } from '$lib/typed-mesh-runtime';

export const healthStore = writable({
    totalCells: 0,
    status: "LOADING" as const
});

// Poll mesh health
setInterval(async () => {
    const health = await mesh.mesh.health();
    healthStore.set(health);
}, 5000);


Example 4: Form submission with validation
────────────────────────────────────────────

<script lang="ts">
    import { mesh } from '$lib/typed-mesh-runtime';
    
    let text = '';
    let type: 'task' | 'idea' = 'task';
    
    async function submit() {
        // ✅ Type-safe - IDE will validate this
        const result = await mesh.list.add({ text, type });
        
        if (result.ok) {
            console.log(`Added item ${result.item.id}`);
            text = '';
        }
    }
    
    // ❌ These would be compile errors:
    // await mesh.list.add({ txt: "typo" });
    // await mesh.list.add({ text: "test", type: "invalid" });
</script>

*/